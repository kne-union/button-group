{"version":3,"file":"static/js/872.bbb90254.chunk.js","mappings":"oLAIA,MAs0EA,EAt0EqB,CACjBA,KAAM,eACNC,QAAS,ytUAiITC,YAAa,+HACbC,YAAa,oBACbC,IAAK,0oXAoeLC,QAAS,CACLC,QAAQ,EACRC,UAAW,GACXC,MAAO,GACPC,KAAM,CAAC,CACXC,MAAO,uCACPR,YAAa,qTACbS,KAAM,kxRA8PNC,MAAO,CAAC,CACRZ,KAAM,eACNG,YAAa,gCACbU,gBAAiB,oDACjBC,UAAW,GACb,CACEd,KAAM,OACNG,YAAa,OACbW,UAAW,KAEb,CACEJ,MAAO,yCACPR,YAAa,2PACbS,KAAM,o1TAsSNC,MAAO,CAAC,CACRZ,KAAM,eACNG,YAAa,gCACbU,gBAAiB,oDACjBC,UAAW,GACb,CACEd,KAAM,OACNG,YAAa,OACbW,UAAW,KAEb,CACEJ,MAAO,yCACPR,YAAa,qPACbS,KAAM,u9aAsZNC,MAAO,CAAC,CACRZ,KAAM,eACNG,YAAa,gCACbU,gBAAiB,oDACjBC,UAAW,GACb,CACEd,KAAM,OACNG,YAAa,OACbW,UAAW,KAEb,CACEJ,MAAO,uCACPR,YAAa,kPACbS,KAAM,06ZAkZNC,MAAO,CAAC,CACRZ,KAAM,eACNG,YAAa,gCACbU,gBAAiB,oDACjBC,UAAW,GACb,CACEd,KAAM,OACNG,YAAa,OACbW,UAAW,KAEb,CACEJ,MAAO,8CACPR,YAAa,qQACbS,KAAM,+5YAyUNC,MAAO,CAAC,CACRZ,KAAM,eACNG,YAAa,gCACbU,gBAAiB,oDACjBC,UAAW,GACb,CACEd,KAAM,OACNG,YAAa,OACbW,UAAW,O","sources":["../../README.md"],"sourcesContent":["import * as component_1 from '@kne/current-lib_button-group';\nimport * as component_2 from 'antd';\nimport '@kne/current-lib_button-group/dist/index.css';\nimport '@kne/current-lib_button-group/dist/index.css';\nconst readmeConfig = {\n    name: `button-group`,\n    summary: `<p>@kne/button-group 是一个 React 按钮组件库，提供了一系列功能丰富的按钮组件，用于简化常见的按钮交互场景。该库专注于提供自适应布局、加载状态管理、确认操作和数据请求等功能，使开发者能够快速实现各种复杂的按钮交互需求。</p>\n<h3>ButtonGroup</h3>\n<p>自适应按钮组组件，能够根据容器宽度自动调整显示的按钮数量。当容器宽度不足以显示所有按钮时，会自动将多余的按钮放入下拉菜单中，确保界面布局美观且功能完整。</p>\n<p><strong>主要特性：</strong></p>\n<ul>\n<li>自动适应容器宽度</li>\n<li>支持紧凑模式（Space.Compact）</li>\n<li>支持链接样式（适用于表格操作列）</li>\n<li>可指定显示的按钮数量</li>\n<li>支持禁用、隐藏状态</li>\n<li>支持自定义按钮渲染</li>\n<li>支持禁用按钮的工具提示</li>\n</ul>\n<p><strong>适用场景：</strong></p>\n<ul>\n<li>操作栏、工具栏</li>\n<li>表格操作列</li>\n<li>面板标题栏</li>\n<li>任何需要自适应按钮布局的场景</li>\n</ul>\n<h3>LoadingButton</h3>\n<p>封装了加载状态的按钮组件，简化了异步操作的处理。通过内置的状态管理，在异步操作执行期间自动显示加载状态，提升用户体验。同时提供了 useLoading hook，方便在其他组件中复用加载状态管理逻辑。</p>\n<p><strong>主要特性：</strong></p>\n<ul>\n<li>自动管理加载状态</li>\n<li>支持自定义加载文案</li>\n<li>自动处理错误情况</li>\n<li>支持 loading 属性手动控制</li>\n<li>提供的 useLoading Hook 可在其他组件使用</li>\n</ul>\n<p><strong>适用场景：</strong></p>\n<ul>\n<li>表单提交按钮</li>\n<li>数据导出按钮</li>\n<li>任何需要异步操作的按钮</li>\n<li>非按钮组件的异步状态管理</li>\n</ul>\n<h3>ConfirmButton</h3>\n<p>带有确认功能的按钮组件，支持弹窗确认（Popconfirm）和模态框确认（Modal）两种模式。适用于需要用户二次确认的操作，如删除、提交等重要操作。同时提供了 ConfirmLink 和 ConfirmText 变体，以及 withConfirm 高阶组件，满足不同场景的确认需求。</p>\n<p><strong>主要特性：</strong></p>\n<ul>\n<li>支持 Popconfirm 和 Modal 两种确认模式</li>\n<li>支持危险操作样式（红色按钮）</li>\n<li>可自定义确认和取消按钮文案</li>\n<li>提供 ConfirmLink 和 ConfirmText 变体</li>\n<li>确认时自动显示加载状态</li>\n</ul>\n<p><strong>适用场景：</strong></p>\n<ul>\n<li>删除操作</li>\n<li>数据提交</li>\n<li>审核操作</li>\n<li>表格行操作（使用 ConfirmLink/ConfirmText）</li>\n<li>任何需要用户二次确认的操作</li>\n</ul>\n<h3>FetchButton</h3>\n<p>集成了数据请求功能的按钮组件，基于 @kne/react-fetch 库实现。可以直接处理 API 请求，并在请求过程中自动管理加载状态，简化了数据交互的实现。</p>\n<p><strong>主要特性：</strong></p>\n<ul>\n<li>自动管理请求加载状态</li>\n<li>支持请求成功/失败回调</li>\n<li>支持参数传递</li>\n<li>支持请求拦截（beforeFetch）</li>\n<li>基于 @kne/react-fetch 实现</li>\n</ul>\n<p><strong>适用场景：</strong></p>\n<ul>\n<li>数据刷新按钮</li>\n<li>文件导出按钮</li>\n<li>API 请求按钮</li>\n<li>任何按钮触发的数据请求场景</li>\n</ul>\n<h3>ButtonFooter</h3>\n<p>页面底部按钮区域组件，可以自动计算高度并设置 CSS 变量，方便页面布局和样式调整。在小屏幕下，会自动将内容渲染到 body，确保按钮始终可见。</p>\n<p><strong>主要特性：</strong></p>\n<ul>\n<li>自动计算高度并设置 CSS 变量</li>\n<li>响应式设计，小屏幕下固定到底部</li>\n<li>支持多种布局方式（居中、左右分布等）</li>\n<li>适用于表单页面的底部操作区</li>\n</ul>\n<p><strong>适用场景：</strong></p>\n<ul>\n<li>表单页面底部操作按钮</li>\n<li>详情页面底部操作按钮</li>\n<li>对话框底部按钮</li>\n<li>任何需要固定在底部的操作按钮区域</li>\n</ul>\n<h2>组件关系</h2>\n<pre><code>ButtonGroup (自适应布局)\n  ├── LoadingButton (加载状态)\n  ├── ConfirmButton (确认功能)\n  │   ├── ConfirmLink (链接变体)\n  │   └── ConfirmText (文本变体)\n  └── FetchButton (数据请求)\n      └── 基于 LoadingButton\n\nButtonFooter (底部固定区域)\n</code></pre>\n<h2>设计理念</h2>\n<p>该组件库的设计理念是通过封装常见的按钮交互模式，提供开箱即用的解决方案，同时保持足够的灵活性和可扩展性：</p>\n<ol>\n<li>\n<p><strong>关注点分离</strong>：每个组件专注于解决特定的问题，如 ButtonGroup 专注于布局，LoadingButton 专注于状态管理。</p>\n</li>\n<li>\n<p><strong>组合优于继承</strong>：通过组合不同的功能组件，可以实现复杂的交互需求，如 FetchButton 就是 LoadingButton 与数据请求功能的组合。</p>\n</li>\n<li>\n<p><strong>声明式 API</strong>：提供简洁明了的 API，使开发者能够以声明式的方式描述 UI 和交互行为。</p>\n</li>\n<li>\n<p><strong>渐进式增强</strong>：基础组件可以独立使用，也可以与其他组件组合使用，实现更复杂的功能。</p>\n</li>\n<li>\n<p><strong>用户体验优先</strong>：注重细节，如自适应布局、加载状态反馈等，提升最终用户的使用体验。</p>\n</li>\n</ol>\n<h2>特性总结</h2>\n<ul>\n<li><strong>自适应布局</strong>：根据容器宽度自动调整按钮显示方式</li>\n<li><strong>加载状态管理</strong>：简化异步操作的加载状态处理</li>\n<li><strong>操作确认</strong>：提供多种确认模式，增强用户操作安全性</li>\n<li><strong>数据请求集成</strong>：简化按钮与后端 API 的交互</li>\n<li><strong>国际化支持</strong>：内置中英文语言包</li>\n<li><strong>高度可定制</strong>：组件提供丰富的配置选项</li>\n<li><strong>响应式设计</strong>：适配不同屏幕尺寸</li>\n<li><strong>TypeScript 友好</strong>：完整的类型定义</li>\n</ul>`,\n    description: `实现了一个按钮组,loading按钮,确认按钮和加载按钮.`,\n    packageName: `@kne/button-group`,\n    api: `<p>自适应按钮组组件，能够根据容器宽度自动调整显示的按钮数量，并将多余的按钮放入下拉菜单中。</p>\n<h3>属性</h3>\n<table>\n<thead>\n<tr>\n<th>属性名</th>\n<th>类型</th>\n<th>默认值</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>list</td>\n<td>Array&lt;object | function&gt;</td>\n<td>[]</td>\n<td>按钮列表，可以是配置对象或渲染函数</td>\n</tr>\n<tr>\n<td>compact</td>\n<td>boolean</td>\n<td>false</td>\n<td>是否使用紧凑模式（Space.Compact）</td>\n</tr>\n<tr>\n<td>showLength</td>\n<td>number</td>\n<td>-</td>\n<td>指定显示的按钮数量，不指定则自动计算</td>\n</tr>\n<tr>\n<td>more</td>\n<td>ReactNode</td>\n<td>-</td>\n<td>自定义\"更多\"按钮</td>\n</tr>\n<tr>\n<td>moreType</td>\n<td>'default' | 'link'</td>\n<td>'default'</td>\n<td>更多按钮类型</td>\n</tr>\n<tr>\n<td>getPopupContainer</td>\n<td>function</td>\n<td>-</td>\n<td>下拉菜单渲染父节点</td>\n</tr>\n<tr>\n<td>trigger</td>\n<td>string</td>\n<td>-</td>\n<td>下拉菜单触发方式</td>\n</tr>\n<tr>\n<td>itemClassName</td>\n<td>string</td>\n<td>-</td>\n<td>按钮项的自定义类名</td>\n</tr>\n<tr>\n<td>...SpaceProps</td>\n<td>-</td>\n<td>-</td>\n<td>Space 组件的其他属性（size、split、align、style等）</td>\n</tr>\n</tbody>\n</table>\n<h3>list 配置项</h3>\n<p>当 list 项为对象时，支持以下属性：</p>\n<table>\n<thead>\n<tr>\n<th>属性名</th>\n<th>类型</th>\n<th>默认值</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>children</td>\n<td>ReactNode</td>\n<td>-</td>\n<td>按钮内容</td>\n</tr>\n<tr>\n<td>type</td>\n<td>string</td>\n<td>-</td>\n<td>按钮类型（primary、default、dashed、link、text）</td>\n</tr>\n<tr>\n<td>disabled</td>\n<td>boolean</td>\n<td>false</td>\n<td>是否禁用</td>\n</tr>\n<tr>\n<td>hidden</td>\n<td>boolean</td>\n<td>false</td>\n<td>是否隐藏</td>\n</tr>\n<tr>\n<td>confirm</td>\n<td>boolean</td>\n<td>false</td>\n<td>是否需要确认</td>\n</tr>\n<tr>\n<td>message</td>\n<td>string | ReactNode</td>\n<td>-</td>\n<td>确认提示内容（设置后会自动使用 ConfirmButton）</td>\n</tr>\n<tr>\n<td>isDelete</td>\n<td>boolean</td>\n<td>false</td>\n<td>是否为删除操作（红色按钮）</td>\n</tr>\n<tr>\n<td>isModal</td>\n<td>boolean</td>\n<td>false</td>\n<td>是否使用模态框确认（在下拉菜单中自动启用）</td>\n</tr>\n<tr>\n<td>buttonComponent</td>\n<td>ReactComponent</td>\n<td>-</td>\n<td>自定义按钮组件</td>\n</tr>\n<tr>\n<td>tooltipProps</td>\n<td>object</td>\n<td>-</td>\n<td>Tooltip 组件属性（禁用时显示提示）</td>\n</tr>\n<tr>\n<td>...ButtonProps</td>\n<td>-</td>\n<td>-</td>\n<td>Button 组件的其他属性</td>\n</tr>\n</tbody>\n</table>\n<p>当 list 项为函数时，函数签名为：</p>\n<pre><code class=\"language-typescript\">(props: { key: number; className: string }, context: { isDropdown: boolean }) =&gt; ReactNode\n</code></pre>\n<hr>\n<h2>LoadingButton</h2>\n<p>封装了加载状态的按钮组件，简化异步操作的处理。</p>\n<h3>属性</h3>\n<table>\n<thead>\n<tr>\n<th>属性名</th>\n<th>类型</th>\n<th>默认值</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>onClick</td>\n<td>function | Promise</td>\n<td>-</td>\n<td>点击按钮时的回调函数，可以返回 Promise</td>\n</tr>\n<tr>\n<td>loading</td>\n<td>boolean</td>\n<td>false</td>\n<td>是否显示加载状态</td>\n</tr>\n<tr>\n<td>disabled</td>\n<td>boolean</td>\n<td>false</td>\n<td>是否禁用按钮</td>\n</tr>\n<tr>\n<td>children</td>\n<td>ReactNode | function</td>\n<td>-</td>\n<td>按钮内容，可以是函数接收 loading 状态</td>\n</tr>\n<tr>\n<td>...ButtonProps</td>\n<td>-</td>\n<td>-</td>\n<td>Button 组件的其他属性</td>\n</tr>\n</tbody>\n</table>\n<h3>useLoading Hook</h3>\n<p>用于管理异步操作加载状态的 Hook。</p>\n<h4>参数</h4>\n<table>\n<thead>\n<tr>\n<th>参数名</th>\n<th>类型</th>\n<th>默认值</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>callback</td>\n<td>function</td>\n<td>-</td>\n<td>异步回调函数</td>\n</tr>\n</tbody>\n</table>\n<h4>返回值</h4>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>类型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>isLoading</td>\n<td>boolean</td>\n<td>当前加载状态</td>\n</tr>\n<tr>\n<td>setIsLoading</td>\n<td>function</td>\n<td>设置加载状态的函数</td>\n</tr>\n<tr>\n<td>callback</td>\n<td>function</td>\n<td>包装后的回调函数</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h2>ConfirmButton</h2>\n<p>带有确认功能的按钮组件，支持弹窗确认和模态框确认两种模式。</p>\n<h3>属性</h3>\n<table>\n<thead>\n<tr>\n<th>属性名</th>\n<th>类型</th>\n<th>默认值</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>children</td>\n<td>ReactNode</td>\n<td>-</td>\n<td>按钮内容</td>\n</tr>\n<tr>\n<td>onClick</td>\n<td>function | Promise</td>\n<td>-</td>\n<td>确认后的回调函数，可以返回 Promise</td>\n</tr>\n<tr>\n<td>title</td>\n<td>string | ReactNode</td>\n<td>-</td>\n<td>确认框标题</td>\n</tr>\n<tr>\n<td>message</td>\n<td>string | ReactNode</td>\n<td>-</td>\n<td>确认框内容</td>\n</tr>\n<tr>\n<td>okText</td>\n<td>string</td>\n<td>-</td>\n<td>确认按钮文字（默认根据 isDelete 动态显示）</td>\n</tr>\n<tr>\n<td>cancelText</td>\n<td>string</td>\n<td>-</td>\n<td>取消按钮文字</td>\n</tr>\n<tr>\n<td>isModal</td>\n<td>boolean</td>\n<td>false</td>\n<td>是否使用模态框确认（默认为 Popconfirm）</td>\n</tr>\n<tr>\n<td>isDelete</td>\n<td>boolean</td>\n<td>true</td>\n<td>是否为删除操作（红色按钮、确认按钮）</td>\n</tr>\n<tr>\n<td>showCancel</td>\n<td>boolean</td>\n<td>true</td>\n<td>是否显示取消按钮</td>\n</tr>\n<tr>\n<td>placement</td>\n<td>string</td>\n<td>-</td>\n<td>Popconfirm 的位置</td>\n</tr>\n<tr>\n<td>getContainer</td>\n<td>function</td>\n<td>-</td>\n<td>确认框渲染容器</td>\n</tr>\n<tr>\n<td>renderModal</td>\n<td>function</td>\n<td>-</td>\n<td>自定义 Modal 渲染函数</td>\n</tr>\n<tr>\n<td>onCancel</td>\n<td>function</td>\n<td>-</td>\n<td>取消按钮的回调</td>\n</tr>\n<tr>\n<td>...ButtonProps</td>\n<td>-</td>\n<td>-</td>\n<td>Button 组件的其他属性</td>\n</tr>\n</tbody>\n</table>\n<h3>ConfirmLink</h3>\n<p>ConfirmButton 的链接样式变体。</p>\n<h3>ConfirmText</h3>\n<p>ConfirmButton 的纯文本样式变体。</p>\n<h3>withConfirm</h3>\n<p>高阶组件，用于为任意组件添加确认功能。</p>\n<blockquote>\n<p>⚠️ 该 API 已标记为废弃，后续版本可能删除，建议不要使用。</p>\n</blockquote>\n<hr>\n<h2>FetchButton</h2>\n<p>集成了数据请求功能的按钮组件，基于 @kne/react-fetch 库实现。</p>\n<h3>属性</h3>\n<table>\n<thead>\n<tr>\n<th>属性名</th>\n<th>类型</th>\n<th>默认值</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>api</td>\n<td>object | function</td>\n<td>-</td>\n<td>请求 API 配置</td>\n</tr>\n<tr>\n<td>params</td>\n<td>object</td>\n<td>-</td>\n<td>请求参数</td>\n</tr>\n<tr>\n<td>onSuccess</td>\n<td>function</td>\n<td>-</td>\n<td>请求成功回调，参数为 <code>{ data }</code></td>\n</tr>\n<tr>\n<td>onError</td>\n<td>function</td>\n<td>-</td>\n<td>请求失败回调</td>\n</tr>\n<tr>\n<td>beforeFetch</td>\n<td>function</td>\n<td>-</td>\n<td>请求前处理函数，返回 false 可阻止请求</td>\n</tr>\n<tr>\n<td>afterFetch</td>\n<td>function</td>\n<td>-</td>\n<td>请求后处理函数</td>\n</tr>\n<tr>\n<td>fetchOptions</td>\n<td>object</td>\n<td>-</td>\n<td>传递给 fetch 函数的选项</td>\n</tr>\n<tr>\n<td>onClick</td>\n<td>function</td>\n<td>-</td>\n<td>请求成功后的回调（与 onSuccess 相同）</td>\n</tr>\n<tr>\n<td>...LoadingButtonProps</td>\n<td>-</td>\n<td>-</td>\n<td>LoadingButton 组件的其他属性</td>\n</tr>\n</tbody>\n</table>\n<h3>api 配置</h3>\n<p>api 可以是对象或函数：</p>\n<pre><code class=\"language-typescript\">// 对象形式\napi: {\n  loader: async ({ params }) =&gt; {\n    return { data: 'response data' };\n  }\n}\n\n// 函数形式\napi: async ({ params }) =&gt; {\n  return { data: 'response data' };\n}\n</code></pre>\n<hr>\n<h2>ButtonFooter</h2>\n<p>页面底部按钮区域组件，可以自动计算高度并设置 CSS 变量。</p>\n<h3>属性</h3>\n<table>\n<thead>\n<tr>\n<th>属性名</th>\n<th>类型</th>\n<th>默认值</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>children</td>\n<td>ReactNode</td>\n<td>-</td>\n<td>按钮区域内容</td>\n</tr>\n<tr>\n<td>className</td>\n<td>string</td>\n<td>-</td>\n<td>容器的自定义类名</td>\n</tr>\n<tr>\n<td>innerClassName</td>\n<td>string</td>\n<td>-</td>\n<td>内部容器的自定义类名</td>\n</tr>\n<tr>\n<td>target</td>\n<td>HTMLElement</td>\n<td>document.body</td>\n<td>移动端渲染的目标容器</td>\n</tr>\n</tbody>\n</table>\n<h3>特性</h3>\n<ul>\n<li>在小屏幕（≤768px）下，会将内容使用 Portal 渲染到 body</li>\n<li>自动计算高度并设置 CSS 变量</li>\n<li>适用于固定在页面底部的操作按钮区域</li>\n</ul>`,\n    example: {\n        isFull: false,\n        className: ``,\n        style: ``,\n        list: [{\n    title: `ButtonGroup 基础用法`,\n    description: `ButtonGroup 能够根据容器宽度自动调整显示的按钮数量，并将多余的按钮放入下拉菜单中。适用于操作栏、工具栏等场景。`,\n    code: `const { default: ButtonGroup } = _ButtonGroup;\nconst { Flex, Button, Space, Typography } = antd;\nconst { useState } = React;\nconst { Text } = Typography;\n\n// 基础用法 - 自动适应容器宽度\nconst BasicExample = () => {\n  const [width, setWidth] = useState(300);\n  return (\n    <Flex gap={16} vertical>\n      <Text type=\"secondary\">调整容器宽度查看自适应效果</Text>\n      <Flex gap={8}>\n        <div style={{ width: \\`\\${width}px\\`, padding: '12px', background: '#f5f5f5', borderRadius: '8px' }}>\n          <ButtonGroup\n            list={[\n              { type: 'primary', children: '新建' },\n              { type: 'default', children: '编辑' },\n              { type: 'default', children: '导出' },\n              { type: 'default', children: '打印' },\n              { children: '更多操作1', message: '确定执行吗？' },\n              { children: '更多操作2', message: '确定执行吗？' }\n            ]}\n          />\n        </div>\n      </Flex>\n      <Space>\n        <Button onClick={() => setWidth(w => Math.max(200, w - 50))}>减少宽度</Button>\n        <Button onClick={() => setWidth(w => Math.min(600, w + 50))}>增加宽度</Button>\n      </Space>\n    </Flex>\n  );\n};\n\n// 紧凑模式\nconst CompactExample = () => {\n  return (\n    <Flex gap={16} vertical>\n      <Text type=\"secondary\">紧凑模式（适用于工具栏）</Text>\n      <ButtonGroup\n        compact\n        list={[\n          { type: 'primary', children: '保存' },\n          { children: '撤销' },\n          { children: '重做' },\n          { children: '删除', isDelete: true }\n        ]}\n      />\n    </Flex>\n  );\n};\n\n// 链接样式 - 更多按钮\nconst LinkStyleExample = () => {\n  const [width, setWidth] = useState(200);\n  return (\n    <Flex gap={16} vertical>\n      <Text type=\"secondary\">链接样式（适用于表格操作栏）</Text>\n      <div style={{ width: \\`\\${width}px\\` }}>\n        <ButtonGroup\n          moreType=\"link\"\n          list={[\n            { children: '查看', type: 'link' },\n            { children: '编辑', type: 'link' },\n            { children: '删除', type: 'link', isDelete: true, message: '确定删除吗？' },\n            { children: '审核', type: 'link' },\n            { children: '驳回', type: 'link' }\n          ]}\n        />\n      </div>\n      <Space>\n        <Button onClick={() => setWidth(w => Math.max(150, w - 30))}>-</Button>\n        <Button onClick={() => setWidth(w => Math.min(400, w + 30))}>+</Button>\n      </Space>\n    </Flex>\n  );\n};\n\n// 指定显示数量\nconst FixedLengthExample = () => {\n  const [showLength, setShowLength] = useState(2);\n  return (\n    <Flex gap={16} vertical>\n      <Text type=\"secondary\">指定显示按钮数量（showLength）</Text>\n      <Space>\n        <Button\n          type={showLength === 1 ? 'primary' : 'default'}\n          onClick={() => setShowLength(1)}\n        >\n          显示1个\n        </Button>\n        <Button\n          type={showLength === 2 ? 'primary' : 'default'}\n          onClick={() => setShowLength(2)}\n        >\n          显示2个\n        </Button>\n        <Button\n          type={showLength === 3 ? 'primary' : 'default'}\n          onClick={() => setShowLength(3)}\n        >\n          显示3个\n        </Button>\n      </Space>\n      <ButtonGroup\n        showLength={showLength}\n        list={[\n          { type: 'primary', children: '主要操作' },\n          { children: '次要操作1' },\n          { children: '次要操作2' },\n          { children: '次要操作3' },\n          { children: '次要操作4' }\n        ]}\n      />\n    </Flex>\n  );\n};\n\n// 自定义渲染函数\nconst CustomRenderExample = () => {\n  const CustomButton = (props) => (\n    <Button {...props} style={{ borderRadius: '4px' }}>\n      {props.children}\n    </Button>\n  );\n\n  return (\n    <Flex gap={16} vertical>\n      <Text type=\"secondary\">自定义渲染（支持函数式配置）</Text>\n      <div style={{ padding: '12px', background: '#f5f5f5', borderRadius: '8px', width: '280px' }}>\n        <ButtonGroup\n          moreType=\"link\"\n          list={[\n            (props) => <CustomButton {...props} type=\"primary\">自定义按钮</CustomButton>,\n            (props) => <CustomButton {...props}>按钮2</CustomButton>,\n            (props) => <CustomButton {...props}>按钮3</CustomButton>,\n            (props) => <CustomButton {...props}>按钮4</CustomButton>\n          ]}\n        />\n      </div>\n    </Flex>\n  );\n};\n\n// 禁用状态与隐藏\nconst StateExample = () => {\n  const [disabled, setDisabled] = useState(true);\n  const [hidden, setHidden] = useState(true);\n\n  return (\n    <Flex gap={16} vertical>\n      <Text type=\"secondary\">禁用与隐藏状态</Text>\n      <Space>\n        <Button onClick={() => setDisabled(!disabled)}>\n          {disabled ? '启用' : '禁用'}操作3\n        </Button>\n        <Button onClick={() => setHidden(!hidden)}>\n          {hidden ? '显示' : '隐藏'}操作4\n        </Button>\n      </Space>\n      <ButtonGroup\n        list={[\n          { type: 'primary', children: '操作1' },\n          { children: '操作2' },\n          { children: '操作3', disabled },\n          { children: '操作4', hidden },\n          { children: '操作5', message: '确定吗？' }\n        ]}\n      />\n    </Flex>\n  );\n};\n\n// 工具提示\nconst TooltipExample = () => {\n  return (\n    <Flex gap={16} vertical>\n      <Text type=\"secondary\">禁用按钮提示（tooltipProps）</Text>\n      <ButtonGroup\n        list={[\n          { type: 'primary', children: '可用操作' },\n          {\n            children: '已禁用操作',\n            disabled: true,\n            tooltipProps: {\n              title: '此操作暂时不可用，请先完成前置步骤',\n              placement: 'bottom'\n            }\n          },\n          {\n            children: '需要权限',\n            disabled: true,\n            tooltipProps: {\n              title: '您没有执行此操作的权限',\n              placement: 'bottom'\n            }\n          }\n        ]}\n      />\n    </Flex>\n  );\n};\n\nconst BaseExample = () => {\n  return (\n    <Space direction=\"vertical\" size=\"large\">\n      <Typography.Title level={3}>ButtonGroup 自适应按钮组</Typography.Title>\n      <Typography.Paragraph>\n        ButtonGroup 是一个自适应按钮组组件，能够根据容器宽度自动调整显示的按钮数量，\n        多余的按钮会放入下拉菜单中。适用于操作栏、工具栏、表格操作列等场景。\n      </Typography.Paragraph>\n\n      <Flex vertical gap={32}>\n        <div>\n          <Typography.Title level={4}>基础用法</Typography.Title>\n          <BasicExample />\n        </div>\n\n        <div>\n          <Typography.Title level={4}>紧凑模式</Typography.Title>\n          <CompactExample />\n        </div>\n\n        <div>\n          <Typography.Title level={4}>链接样式</Typography.Title>\n          <LinkStyleExample />\n        </div>\n\n        <div>\n          <Typography.Title level={4}>指定显示数量</Typography.Title>\n          <FixedLengthExample />\n        </div>\n\n        <div>\n          <Typography.Title level={4}>自定义渲染</Typography.Title>\n          <CustomRenderExample />\n        </div>\n\n        <div>\n          <Typography.Title level={4}>禁用与隐藏</Typography.Title>\n          <StateExample />\n        </div>\n\n        <div>\n          <Typography.Title level={4}>禁用提示</Typography.Title>\n          <TooltipExample />\n        </div>\n      </Flex>\n    </Space>\n  );\n};\n\nrender(<BaseExample />);\n\n`,\n    scope: [{\n    name: \"_ButtonGroup\",\n    packageName: \"@kne/current-lib_button-group\",\n    importStatement: \"import * as _ButtonGroup from \\\"@kne/button-group\\\"\",\n    component: component_1\n},{\n    name: \"antd\",\n    packageName: \"antd\",\n    component: component_2\n}]\n},{\n    title: `LoadingButton 加载按钮`,\n    description: `LoadingButton 封装了加载状态，简化异步操作的处理。点击按钮时自动显示加载状态，避免重复提交。`,\n    code: `const { LoadingButton, useLoading } = _ButtonGroup;\nconst { Space, Button, Typography, message, Card, Alert, Flex } = antd;\nconst { useState } = React;\n\n// 基础用法 - 自动加载状态\nconst BasicExample = () => {\n  const handleClick = () => {\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        message.success('操作成功！');\n        resolve();\n      }, 1500);\n    });\n  };\n\n  return (\n    <Space direction=\"vertical\">\n      <Typography.Text type=\"secondary\">点击按钮，自动管理加载状态</Typography.Text>\n      <Space wrap>\n        <LoadingButton type=\"primary\" onClick={handleClick}>\n          保存数据\n        </LoadingButton>\n        <LoadingButton onClick={handleClick}>提交审核</LoadingButton>\n        <LoadingButton danger onClick={handleClick}>删除</LoadingButton>\n      </Space>\n    </Space>\n  );\n};\n\n// 自定义加载文案\nconst CustomTextExample = () => {\n  const handleClick = () => {\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        message.success('上传完成');\n        resolve();\n      }, 2000);\n    });\n  };\n\n  return (\n    <Space direction=\"vertical\">\n      <Typography.Text type=\"secondary\">使用函数自定义加载时的文案</Typography.Text>\n      <Space>\n        <LoadingButton onClick={handleClick}>\n          {(isLoading) => (isLoading ? '正在上传...' : '上传文件')}\n        </LoadingButton>\n        <LoadingButton onClick={handleClick} type=\"primary\">\n          {(isLoading) => (isLoading ? '提交中...' : '提交订单')}\n        </LoadingButton>\n      </Space>\n    </Space>\n  );\n};\n\n// 错误处理\nconst ErrorExample = () => {\n  const [shouldFail, setShouldFail] = useState(false);\n\n  const handleClick = () => {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        if (shouldFail) {\n          message.error('操作失败，请重试');\n          reject(new Error('操作失败'));\n        } else {\n          message.success('操作成功');\n          resolve();\n        }\n      }, 1000);\n    });\n  };\n\n  return (\n    <Space direction=\"vertical\" style={{ width: '100%' }}>\n      <Typography.Text type=\"secondary\">\n        演示错误处理：加载状态会自动解除\n      </Typography.Text>\n      <Space>\n        <Button onClick={() => setShouldFail(!shouldFail)}>\n          {shouldFail ? '切换为成功' : '切换为失败'}\n        </Button>\n      </Space>\n      <Space>\n        <LoadingButton onClick={handleClick}>\n          {shouldFail ? '会失败的操作' : '会成功的操作'}\n        </LoadingButton>\n      </Space>\n      {shouldFail && <Alert message=\"当前设置为失败模式\" type=\"warning\" />}\n    </Space>\n  );\n};\n\n// 手动控制加载状态\nconst ManualExample = () => {\n  const [loading, setLoading] = useState(false);\n\n  const handleClick = () => {\n    setLoading(true);\n    setTimeout(() => {\n      setLoading(false);\n      message.success('手动控制加载完成');\n    }, 2000);\n  };\n\n  return (\n    <Space direction=\"vertical\">\n      <Typography.Text type=\"secondary\">通过 loading 属性手动控制加载状态</Typography.Text>\n      <LoadingButton loading={loading} onClick={handleClick}>\n        手动控制加载\n      </LoadingButton>\n    </Space>\n  );\n};\n\n// useLoading Hook 示例\nconst UseLoadingExample = () => {\n  const { isLoading, callback } = useLoading(() => {\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        message.success('Hook 模式操作完成');\n        resolve();\n      }, 1500);\n    });\n  });\n\n  return (\n    <Card title=\"useLoading Hook\" style={{ width: 400 }}>\n      <Space direction=\"vertical\" style={{ width: '100%' }}>\n        <Typography.Text type=\"secondary\">\n          在非按钮组件中使用 useLoading 管理异步状态\n        </Typography.Text>\n        <Space>\n          <Button onClick={callback} loading={isLoading}>\n            使用 Hook\n          </Button>\n          <Button onClick={() => {}}>\n            独立按钮（不受影响）\n          </Button>\n        </Space>\n        {isLoading && (\n          <Alert message=\"当前状态：加载中\" type=\"info\" showIcon />\n        )}\n      </Space>\n    </Card>\n  );\n};\n\n// 不同按钮类型\nconst ButtonTypesExample = () => {\n  const handleClick = () => {\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        message.success('完成');\n        resolve();\n      }, 1000);\n    });\n  };\n\n  return (\n    <Space direction=\"vertical\">\n      <Typography.Text type=\"secondary\">支持所有 Ant Design Button 类型</Typography.Text>\n      <Space wrap>\n        <LoadingButton type=\"primary\" onClick={handleClick}>Primary</LoadingButton>\n        <LoadingButton type=\"default\" onClick={handleClick}>Default</LoadingButton>\n        <LoadingButton type=\"dashed\" onClick={handleClick}>Dashed</LoadingButton>\n        <LoadingButton type=\"link\" onClick={handleClick}>Link</LoadingButton>\n        <LoadingButton type=\"text\" onClick={handleClick}>Text</LoadingButton>\n      </Space>\n      <Space wrap>\n        <LoadingButton type=\"primary\" ghost onClick={handleClick}>Primary Ghost</LoadingButton>\n        <LoadingButton type=\"default\" ghost onClick={handleClick}>Default Ghost</LoadingButton>\n      </Space>\n    </Space>\n  );\n};\n\n// 图标按钮\nconst IconExample = () => {\n  const handleClick = () => {\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        message.success('操作完成');\n        resolve();\n      }, 1200);\n    });\n  };\n\n  return (\n    <Space direction=\"vertical\">\n      <Typography.Text type=\"secondary\">支持图标</Typography.Text>\n      <Space>\n        <LoadingButton type=\"primary\" icon={<span>⬆️</span>} onClick={handleClick}>\n          上传\n        </LoadingButton>\n        <LoadingButton icon={<span>⬇️</span>} onClick={handleClick}>\n          下载\n        </LoadingButton>\n        <LoadingButton danger icon={<span>🗑️</span>} onClick={handleClick}>\n          删除\n        </LoadingButton>\n      </Space>\n    </Space>\n  );\n};\n\n// 实际应用场景 - 表单提交\nconst FormSubmitExample = () => {\n  const handleSubmit = async () => {\n    // 模拟表单验证\n    await new Promise(resolve => setTimeout(resolve, 500));\n    // 模拟 API 请求\n    await new Promise((resolve) => {\n      setTimeout(() => {\n        message.success('表单提交成功！');\n        resolve();\n      }, 1500);\n    });\n  };\n\n  return (\n    <Card title=\"表单提交场景\" style={{ width: 400 }}>\n      <Space direction=\"vertical\" style={{ width: '100%' }}>\n        <Typography.Text type=\"secondary\">\n          点击提交按钮，自动防止重复提交\n        </Typography.Text>\n        <Space>\n          <LoadingButton type=\"primary\" onClick={handleSubmit}>\n            提交表单\n          </LoadingButton>\n          <Button onClick={() => message.info('已取消')}>取消</Button>\n        </Space>\n      </Space>\n    </Card>\n  );\n};\n\nconst BaseExample = () => {\n  return (\n    <Space direction=\"vertical\" size=\"large\">\n      <Typography.Title level={3}>LoadingButton 加载按钮</Typography.Title>\n      <Typography.Paragraph>\n        LoadingButton 封装了加载状态，简化异步操作的处理。点击按钮时自动显示加载状态，\n        避免重复提交，同时提供 useLoading Hook 供其他组件使用。\n      </Typography.Paragraph>\n\n      <Flex vertical gap={32}>\n        <div>\n          <Typography.Title level={4}>基础用法</Typography.Title>\n          <BasicExample />\n        </div>\n\n        <div>\n          <Typography.Title level={4}>自定义加载文案</Typography.Title>\n          <CustomTextExample />\n        </div>\n\n        <div>\n          <Typography.Title level={4}>错误处理</Typography.Title>\n          <ErrorExample />\n        </div>\n\n        <div>\n          <Typography.Title level={4}>手动控制加载状态</Typography.Title>\n          <ManualExample />\n        </div>\n\n        <div>\n          <Typography.Title level={4}>useLoading Hook</Typography.Title>\n          <UseLoadingExample />\n        </div>\n\n        <div>\n          <Typography.Title level={4}>不同按钮类型</Typography.Title>\n          <ButtonTypesExample />\n        </div>\n\n        <div>\n          <Typography.Title level={4}>图标按钮</Typography.Title>\n          <IconExample />\n        </div>\n\n        <div>\n          <Typography.Title level={4}>实际应用场景</Typography.Title>\n          <FormSubmitExample />\n        </div>\n      </Flex>\n    </Space>\n  );\n};\n\nrender(<BaseExample />);\n\n`,\n    scope: [{\n    name: \"_ButtonGroup\",\n    packageName: \"@kne/current-lib_button-group\",\n    importStatement: \"import * as _ButtonGroup from \\\"@kne/button-group\\\"\",\n    component: component_1\n},{\n    name: \"antd\",\n    packageName: \"antd\",\n    component: component_2\n}]\n},{\n    title: `ConfirmButton 确认按钮`,\n    description: `ConfirmButton 带有确认功能，支持弹窗确认和模态框确认两种模式。适用于删除、提交等重要操作。`,\n    code: `const { ConfirmButton, ConfirmLink, ConfirmText } = _ButtonGroup;\nconst { Flex, Space, Typography, message, Card, List, Tag, Button } = antd;\nconst { useState } = React;\n\n// 基础用法 - Popconfirm 模式\nconst BasicExample = () => {\n  const handleDelete = () => {\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        message.success('删除成功');\n        resolve();\n      }, 500);\n    });\n  };\n\n  return (\n    <Space direction=\"vertical\">\n      <Typography.Text type=\"secondary\">\n        Popconfirm 模式（气泡确认框），适用于快速确认\n      </Typography.Text>\n      <Space>\n        <ConfirmButton message=\"确定要删除吗？\" onClick={handleDelete}>\n          删除\n        </ConfirmButton>\n        <ConfirmButton message=\"确定要提交吗？\" onClick={handleDelete}>\n          提交\n        </ConfirmButton>\n      </Space>\n    </Space>\n  );\n};\n\n// Modal 模式\nconst ModalExample = () => {\n  const handleSubmit = () => {\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        message.success('提交成功');\n        resolve();\n      }, 500);\n    });\n  };\n\n  return (\n    <Space direction=\"vertical\">\n      <Typography.Text type=\"secondary\">\n        Modal 模式（模态框），适用于重要操作或长内容提示\n      </Typography.Text>\n      <Space>\n        <ConfirmButton\n          isModal\n          message=\"此操作将永久删除该数据，删除后无法恢复。确定要继续吗？\"\n          onClick={handleSubmit}\n        >\n          删除数据\n        </ConfirmButton>\n        <ConfirmButton\n          isModal\n          title=\"提交确认\"\n          message=\"提交后数据将进入审核流程，确认要提交吗？\"\n          onClick={handleSubmit}\n        >\n          提交审核\n        </ConfirmButton>\n      </Space>\n    </Space>\n  );\n};\n\n// 危险操作样式\nconst DangerExample = () => {\n  const handleDelete = () => {\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        message.success('已删除');\n        resolve();\n      }, 500);\n    });\n  };\n\n  return (\n    <Space direction=\"vertical\">\n      <Typography.Text type=\"secondary\">\n        使用 isDelete 标识危险操作（红色按钮）\n      </Typography.Text>\n      <Space>\n        <ConfirmButton\n          danger\n          message=\"确定删除吗？\"\n          onClick={handleDelete}\n        >\n          普通按钮\n        </ConfirmButton>\n        <ConfirmButton\n          isDelete\n          message=\"确定删除吗？\"\n          onClick={handleDelete}\n        >\n          删除按钮\n        </ConfirmButton>\n        <ConfirmButton\n          isDelete\n          isModal\n          message=\"此操作无法撤销，确定要继续吗？\"\n          onClick={handleDelete}\n        >\n          删除（Modal）\n        </ConfirmButton>\n      </Space>\n    </Space>\n  );\n};\n\n// 自定义确认文案\nconst CustomTextExample = () => {\n  const handleAction = () => {\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        message.success('操作完成');\n        resolve();\n      }, 500);\n    });\n  };\n\n  return (\n    <Space direction=\"vertical\">\n      <Typography.Text type=\"secondary\">自定义确认和取消按钮文案</Typography.Text>\n      <Space>\n        <ConfirmButton\n          message=\"确定要执行此操作吗？\"\n          okText=\"确认执行\"\n          cancelText=\"暂不执行\"\n          onClick={handleAction}\n        >\n          自定义文案\n        </ConfirmButton>\n        <ConfirmButton\n          isModal\n          title=\"操作确认\"\n          message=\"请确认是否继续执行此操作\"\n          okText=\"是，继续\"\n          cancelText=\"否，取消\"\n          onClick={handleAction}\n        >\n          Modal 自定义文案\n        </ConfirmButton>\n      </Space>\n    </Space>\n  );\n};\n\n// ConfirmLink 和 ConfirmText\nconst LinkAndTextExample = () => {\n  const handleAction = () => {\n    message.success('操作成功');\n    return Promise.resolve();\n  };\n\n  return (\n    <Space direction=\"vertical\" style={{ width: '100%' }}>\n      <Typography.Text type=\"secondary\">\n        ConfirmLink 和 ConfirmText 变体，适用于表格行操作等场景\n      </Typography.Text>\n      <List\n        bordered\n        style={{ width: 400 }}\n        dataSource={[\n          { id: 1, name: '数据项 A', status: '已提交' },\n          { id: 2, name: '数据项 B', status: '草稿' },\n          { id: 3, name: '数据项 C', status: '已审核' }\n        ]}\n        renderItem={(item) => (\n          <List.Item\n            actions={[\n              <ConfirmLink key=\"edit\" message=\"确定编辑吗？\" onClick={handleAction}>\n                编辑\n              </ConfirmLink>,\n              <ConfirmLink key=\"delete\" isDelete message=\"确定删除吗？\" onClick={handleAction}>\n                删除\n              </ConfirmLink>\n            ]}\n          >\n            <List.Item.Meta\n              title={item.name}\n              description={<Tag color={item.status === '已提交' ? 'blue' : 'default'}>{item.status}</Tag>}\n            />\n          </List.Item>\n        )}\n      />\n      <Space>\n        <ConfirmText onClick={handleAction}>纯文本确认</ConfirmText>\n        <Typography.Text type=\"secondary\">|</Typography.Text>\n        <ConfirmText isDelete onClick={handleAction}>删除</ConfirmText>\n      </Space>\n    </Space>\n  );\n};\n\n// 禁用状态\nconst DisabledExample = () => {\n  const [disabled, setDisabled] = useState(true);\n  const handleDelete = () => {\n    message.success('已删除');\n    return Promise.resolve();\n  };\n\n  return (\n    <Space direction=\"vertical\">\n      <Typography.Text type=\"secondary\">禁用状态下不会触发确认</Typography.Text>\n      <Space>\n        <Button onClick={() => setDisabled(!disabled)}>\n          {disabled ? '启用' : '禁用'}\n        </Button>\n      </Space>\n      <Space>\n        <ConfirmButton disabled={disabled} message=\"确定删除吗？\" onClick={handleDelete}>\n          删除\n        </ConfirmButton>\n        <ConfirmLink disabled={disabled} message=\"确定删除吗？\" onClick={handleDelete}>\n          删除\n        </ConfirmLink>\n      </Space>\n    </Space>\n  );\n};\n\n// 实际应用场景 - 表格操作\nconst TableActionExample = () => {\n  const handleEdit = () => {\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        message.success('进入编辑模式');\n        resolve();\n      }, 300);\n    });\n  };\n\n  const handleDelete = () => {\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        message.success('已删除');\n        resolve();\n      }, 300);\n    });\n  };\n\n  const handleAudit = () => {\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        message.success('审核通过');\n        resolve();\n      }, 300);\n    });\n  };\n\n  return (\n    <Card title=\"实际应用：表格操作栏\" style={{ width: 500 }}>\n      <Space direction=\"vertical\" style={{ width: '100%' }}>\n        <Typography.Text type=\"secondary\">\n          模拟表格中的操作按钮，包含不同的确认方式\n        </Typography.Text>\n        <List\n          bordered\n          dataSource={[\n            { id: 1, name: '产品 A', price: '¥99.00' },\n            { id: 2, name: '产品 B', price: '¥199.00' }\n          ]}\n          renderItem={(item) => (\n            <List.Item\n              actions={[\n                <ConfirmButton key=\"edit\" type=\"link\" message={\\`确定编辑 \\${item.name} 吗？\\`} onClick={handleEdit}>\n                  编辑\n                </ConfirmButton>,\n                <ConfirmButton key=\"audit\" type=\"link\" message={\\`确定通过 \\${item.name} 的审核吗？\\`} onClick={handleAudit}>\n                  审核\n                </ConfirmButton>,\n                <ConfirmButton\n                  key=\"delete\"\n                  type=\"link\"\n                  danger\n                  message={\\`确定删除 \\${item.name} 吗？此操作无法撤销。\\`}\n                  onClick={handleDelete}\n                >\n                  删除\n                </ConfirmButton>\n              ]}\n            >\n              <List.Item.Meta\n                title={item.name}\n                description={item.price}\n              />\n            </List.Item>\n          )}\n        />\n      </Space>\n    </Card>\n  );\n};\n\n// 批量操作\nconst BatchExample = () => {\n  const [selectedCount, setSelectedCount] = useState(0);\n  const handleBatchDelete = () => {\n    return new Promise((resolve) => {\n      setTimeout(() => {\n        message.success(\\`已删除 \\${selectedCount} 条数据\\`);\n        setSelectedCount(0);\n        resolve();\n      }, 500);\n    });\n  };\n\n  return (\n    <Card title=\"批量操作场景\" style={{ width: 450 }}>\n      <Space direction=\"vertical\" style={{ width: '100%' }}>\n        <Space>\n          <Typography.Text type=\"secondary\">已选择：</Typography.Text>\n          <Typography.Text strong>{selectedCount} 项</Typography.Text>\n          <Button size=\"small\" onClick={() => setSelectedCount(Math.floor(Math.random() * 10))}>\n            随机选择\n          </Button>\n        </Space>\n        <Space>\n          <ConfirmButton\n            type=\"primary\"\n            disabled={selectedCount === 0}\n            isModal\n            title=\"批量删除确认\"\n            message={\\`确定要删除选中的 \\${selectedCount} 条数据吗？此操作无法撤销。\\`}\n            onClick={handleBatchDelete}\n          >\n            批量删除\n          </ConfirmButton>\n          <ConfirmButton\n            disabled={selectedCount === 0}\n            message={\\`确定导出选中的 \\${selectedCount} 条数据吗？\\`}\n            onClick={() => {\n              message.success(\\`正在导出 \\${selectedCount} 条数据\\`);\n              return Promise.resolve();\n            }}\n          >\n            导出\n          </ConfirmButton>\n        </Space>\n      </Space>\n    </Card>\n  );\n};\n\nconst BaseExample = () => {\n  return (\n    <Space direction=\"vertical\" size=\"large\">\n      <Typography.Title level={3}>ConfirmButton 确认按钮</Typography.Title>\n      <Typography.Paragraph>\n        ConfirmButton 提供确认功能，支持 Popconfirm（气泡确认框）和 Modal（模态框）两种模式。\n        还提供 ConfirmLink 和 ConfirmText 变体，以及 withConfirm 高阶组件。\n      </Typography.Paragraph>\n\n      <Flex vertical gap={32}>\n        <div>\n          <Typography.Title level={4}>Popconfirm 模式</Typography.Title>\n          <BasicExample />\n        </div>\n\n        <div>\n          <Typography.Title level={4}>Modal 模式</Typography.Title>\n          <ModalExample />\n        </div>\n\n        <div>\n          <Typography.Title level={4}>危险操作样式</Typography.Title>\n          <DangerExample />\n        </div>\n\n        <div>\n          <Typography.Title level={4}>自定义文案</Typography.Title>\n          <CustomTextExample />\n        </div>\n\n        <div>\n          <Typography.Title level={4}>Link 和 Text 变体</Typography.Title>\n          <LinkAndTextExample />\n        </div>\n\n        <div>\n          <Typography.Title level={4}>禁用状态</Typography.Title>\n          <DisabledExample />\n        </div>\n\n        <div>\n          <Typography.Title level={4}>实际应用场景</Typography.Title>\n          <TableActionExample />\n        </div>\n\n        <div>\n          <Typography.Title level={4}>批量操作</Typography.Title>\n          <BatchExample />\n        </div>\n      </Flex>\n    </Space>\n  );\n};\n\nrender(<BaseExample />);\n\n`,\n    scope: [{\n    name: \"_ButtonGroup\",\n    packageName: \"@kne/current-lib_button-group\",\n    importStatement: \"import * as _ButtonGroup from \\\"@kne/button-group\\\"\",\n    component: component_1\n},{\n    name: \"antd\",\n    packageName: \"antd\",\n    component: component_2\n}]\n},{\n    title: `FetchButton 请求按钮`,\n    description: `FetchButton 集成了数据请求功能，自动管理加载状态和请求流程。适用于按钮触发 API 请求的场景。`,\n    code: `const { FetchButton } = _ButtonGroup;\nconst { Space, Typography, message, Card, Alert, Form, Input, Select, Button, Flex } = antd;\nconst { useState } = React;\n\n// 基础用法\nconst BasicExample = () => {\n  const handleSuccess = ({ data }) => {\n    message.success(\\`获取数据成功: \\${data}\\`);\n  };\n\n  return (\n    <Space direction=\"vertical\" style={{ width: '100%' }}>\n      <Typography.Text type=\"secondary\">\n        点击按钮触发 API 请求，自动管理加载状态\n      </Typography.Text>\n      <FetchButton\n        type=\"primary\"\n        api={{\n          loader: async () => {\n            return new Promise((resolve) => {\n              setTimeout(() => {\n                resolve({ data: '用户信息数据' });\n              }, 1500);\n            });\n          }\n        }}\n        onClick={handleSuccess}\n      >\n        获取用户信息\n      </FetchButton>\n    </Space>\n  );\n};\n\n// 带参数请求\nconst WithParamsExample = () => {\n  const [userId, setUserId] = useState('1');\n\n  const handleSuccess = ({ data }) => {\n    message.success(\\`获取成功: \\${JSON.stringify(data)}\\`);\n  };\n\n  return (\n    <Space direction=\"vertical\" style={{ width: '100%' }}>\n      <Typography.Text type=\"secondary\">传递参数到 API 请求</Typography.Text>\n      <Space>\n        <Select\n          value={userId}\n          onChange={setUserId}\n          style={{ width: 120 }}\n          options={[\n            { value: '1', label: '用户1' },\n            { value: '2', label: '用户2' },\n            { value: '3', label: '用户3' }\n          ]}\n        />\n        <FetchButton\n          params={{ userId }}\n          api={{\n            loader: async ({ params }) => {\n              return new Promise((resolve) => {\n                setTimeout(() => {\n                  resolve({ data: { userId: params.userId, name: \\`用户\\${params.userId}\\`, role: '管理员' } });\n                }, 1000);\n              });\n            }\n          }}\n          onClick={handleSuccess}\n        >\n          获取用户详情\n        </FetchButton>\n      </Space>\n    </Space>\n  );\n};\n\n// 成功和失败回调\nconst CallbackExample = () => {\n  const [status, setStatus] = useState('');\n  const [shouldFail, setShouldFail] = useState(false);\n\n  const handleSuccess = ({ data }) => {\n    setStatus('success');\n    message.success('数据加载成功');\n    console.log('成功数据:', data);\n  };\n\n  const handleError = (error) => {\n    setStatus('error');\n    message.error('数据加载失败');\n    console.error('错误信息:', error);\n  };\n\n  return (\n    <Card title=\"成功与失败回调\" style={{ width: 450 }}>\n      <Space direction=\"vertical\" style={{ width: '100%' }}>\n        <Space>\n          <Button onClick={() => setShouldFail(!shouldFail)} size=\"small\">\n            {shouldFail ? '切换为成功' : '切换为失败'}\n          </Button>\n        </Space>\n        <FetchButton\n          type=\"primary\"\n          api={{\n            loader: async () => {\n              return new Promise((resolve, reject) => {\n                setTimeout(() => {\n                  if (shouldFail) {\n                    reject(new Error('模拟的请求失败'));\n                  } else {\n                    resolve({ data: { message: '请求成功', timestamp: Date.now() } });\n                  }\n                }, 1000);\n              });\n            }\n          }}\n          onSuccess={handleSuccess}\n          onError={handleError}\n        >\n          {shouldFail ? '失败请求' : '成功请求'}\n        </FetchButton>\n        {status === 'success' && <Alert message=\"上次请求：成功\" type=\"success\" />}\n        {status === 'error' && <Alert message=\"上次请求：失败\" type=\"error\" />}\n      </Space>\n    </Card>\n  );\n};\n\n// 导出文件场景\nconst ExportExample = () => {\n  const handleExport = ({ data }) => {\n    message.success(\\`导出成功: \\${data.url}\\`);\n  };\n\n  return (\n    <Space direction=\"vertical\" style={{ width: '100%' }}>\n      <Typography.Text type=\"secondary\">模拟文件导出场景</Typography.Text>\n      <Space>\n        <FetchButton\n          api={{\n            loader: async () => {\n              return new Promise((resolve) => {\n                setTimeout(() => {\n                  resolve({ data: { url: '/download/report.xlsx', size: '2.5MB' } });\n                }, 2000);\n              });\n            }\n          }}\n          onClick={handleExport}\n        >\n          导出报表\n        </FetchButton>\n        <FetchButton\n          type=\"primary\"\n          api={{\n            loader: async () => {\n              return new Promise((resolve) => {\n                setTimeout(() => {\n                  resolve({ data: { url: '/download/data.csv', size: '1.2MB' } });\n                }, 1500);\n              });\n            }\n          }}\n          onClick={handleExport}\n        >\n          导出 CSV\n        </FetchButton>\n      </Space>\n    </Space>\n  );\n};\n\n// 表单提交场景\nconst FormSubmitExample = () => {\n  const [form] = Form.useForm();\n  const [loading, setLoading] = useState(false);\n  const [submittedData, setSubmittedData] = useState(null);\n\n  const handleSubmit = ({ data }) => {\n    setSubmittedData(data);\n    message.success('表单提交成功');\n  };\n\n  const onFinish = async () => {\n    try {\n      const values = await form.validateFields();\n      setLoading(true);\n      // 使用 FetchButton 内部处理，这里只是演示\n      await new Promise(resolve => setTimeout(resolve, 1000));\n      setLoading(false);\n      message.success('验证通过');\n    } catch (error) {\n      message.error('请检查表单内容');\n    }\n  };\n\n  return (\n    <Card title=\"表单提交场景\" style={{ width: 450 }}>\n      <Space direction=\"vertical\" style={{ width: '100%' }}>\n        <Form\n          form={form}\n          layout=\"vertical\"\n        >\n          <Form.Item\n            name=\"username\"\n            label=\"用户名\"\n            rules={[{ required: true, message: '请输入用户名' }]}\n          >\n            <Input placeholder=\"请输入用户名\" />\n          </Form.Item>\n          <Form.Item\n            name=\"email\"\n            label=\"邮箱\"\n            rules={[{ required: true, message: '请输入邮箱' }]}\n          >\n            <Input placeholder=\"请输入邮箱\" />\n          </Form.Item>\n        </Form>\n        <Space>\n          <FetchButton\n            type=\"primary\"\n            api={{\n              loader: async ({ params }) => {\n                return new Promise((resolve) => {\n                  setTimeout(() => {\n                    resolve({ data: { id: 123, ...params, createTime: new Date().toISOString() } });\n                  }, 1500);\n                });\n              }\n            }}\n            beforeFetch={() => {\n              const values = form.getFieldsValue();\n              if (!values.username || !values.email) {\n                message.error('请填写完整信息');\n                return false;\n              }\n              return true;\n            }}\n            onClick={handleSubmit}\n          >\n            提交表单\n          </FetchButton>\n          <Button onClick={() => form.resetFields()}>重置</Button>\n        </Space>\n        {submittedData && (\n          <Alert\n            message=\"提交成功\"\n            description={JSON.stringify(submittedData, null, 2)}\n            type=\"success\"\n          />\n        )}\n      </Space>\n    </Card>\n  );\n};\n\n// 刷新数据场景\nconst RefreshExample = () => {\n  const [data, setData] = useState(null);\n  const [lastRefresh, setLastRefresh] = useState(null);\n\n  const handleRefresh = ({ data: newData }) => {\n    console.log(newData);\n    setData(newData);\n    setLastRefresh(new Date().toLocaleTimeString());\n    message.success('数据已更新');\n  };\n\n  return (\n    <Card title=\"刷新数据场景\" style={{ width: 450 }}>\n      <Space direction=\"vertical\" style={{ width: '100%' }}>\n        <Space>\n          <Typography.Text type=\"secondary\">上次刷新：</Typography.Text>\n          <Typography.Text>{lastRefresh || '从未刷新'}</Typography.Text>\n        </Space>\n        <FetchButton\n          api={{\n            loader: async () => {\n              return new Promise((resolve) => {\n                setTimeout(() => {\n                  resolve({\n                    users: [\n                      { id: 1, name: '用户A', status: '在线' },\n                      { id: 2, name: '用户B', status: '离线' },\n                      { id: 3, name: '用户C', status: '在线' }\n                    ],\n                    total: 3\n                  });\n                }, 1000);\n              });\n            }\n          }}\n          onClick={handleRefresh}\n        >\n          刷新数据\n        </FetchButton>\n        {data && (\n          <Alert\n            message={\\`当前数据：\\${data.users?.length} 个用户在线\\`}\n            type=\"info\"\n          />\n        )}\n      </Space>\n    </Card>\n  );\n};\n\n// beforeFetch 拦截\nconst BeforeFetchExample = () => {\n  const [allowed, setAllowed] = useState(true);\n\n  const handleFetch = ({ data }) => {\n    message.success('请求通过');\n  };\n\n  const beforeFetch = () => {\n    if (!allowed) {\n      message.warning('请求被 beforeFetch 拦截');\n      return false;\n    }\n    return true;\n  };\n\n  return (\n    <Space direction=\"vertical\">\n      <Typography.Text type=\"secondary\">beforeFetch 可以拦截请求</Typography.Text>\n      <Space>\n        <Button onClick={() => setAllowed(!allowed)} size=\"small\">\n          {allowed ? '拦截请求' : '允许请求'}\n        </Button>\n      </Space>\n      <FetchButton\n        api={{\n          loader: async () => {\n            return new Promise((resolve) => {\n              setTimeout(() => {\n                resolve({ data: '请求成功' });\n              }, 800);\n            });\n          }\n        }}\n        beforeFetch={beforeFetch}\n        onClick={handleFetch}\n      >\n        {allowed ? '发送请求' : '请求已拦截'}\n      </FetchButton>\n    </Space>\n  );\n};\n\nconst BaseExample = () => {\n  return (\n    <Space direction=\"vertical\" size=\"large\">\n      <Typography.Title level={3}>FetchButton 请求按钮</Typography.Title>\n      <Typography.Paragraph>\n        FetchButton 集成了数据请求功能，基于 @kne/react-fetch 库实现。\n        自动管理加载状态，支持成功/失败回调、参数传递、请求拦截等功能。\n      </Typography.Paragraph>\n\n      <Flex vertical gap={32}>\n        <div>\n          <Typography.Title level={4}>基础用法</Typography.Title>\n          <BasicExample />\n        </div>\n\n        <div>\n          <Typography.Title level={4}>带参数请求</Typography.Title>\n          <WithParamsExample />\n        </div>\n\n        <div>\n          <Typography.Title level={4}>成功与失败回调</Typography.Title>\n          <CallbackExample />\n        </div>\n\n        <div>\n          <Typography.Title level={4}>文件导出场景</Typography.Title>\n          <ExportExample />\n        </div>\n\n        <div>\n          <Typography.Title level={4}>表单提交场景</Typography.Title>\n          <FormSubmitExample />\n        </div>\n\n        <div>\n          <Typography.Title level={4}>刷新数据场景</Typography.Title>\n          <RefreshExample />\n        </div>\n\n        <div>\n          <Typography.Title level={4}>请求拦截</Typography.Title>\n          <BeforeFetchExample />\n        </div>\n      </Flex>\n    </Space>\n  );\n};\n\nrender(<BaseExample />);\n\n`,\n    scope: [{\n    name: \"_ButtonGroup\",\n    packageName: \"@kne/current-lib_button-group\",\n    importStatement: \"import * as _ButtonGroup from \\\"@kne/button-group\\\"\",\n    component: component_1\n},{\n    name: \"antd\",\n    packageName: \"antd\",\n    component: component_2\n}]\n},{\n    title: `ButtonFooter 底部按钮区`,\n    description: `ButtonFooter 是页面底部按钮区域组件，在小屏幕下自动将内容渲染到 body，方便表单页面的操作按钮布局。`,\n    code: `const { ButtonFooter } = _ButtonGroup;\nconst { Flex, Button, Space, Typography, Card, Form, Input } = antd;\nconst { useState } = React;\n\n// 基础用法\nconst BasicExample = () => {\n  return (\n    <Space direction=\"vertical\" style={{ width: '100%' }}>\n      <Typography.Text type=\"secondary\">\n        ButtonFooter 固定在页面底部，在小屏幕（≤768px）下自动渲染到 body\n      </Typography.Text>\n      <Card\n        title=\"页面内容区域\"\n        style={{ width: 400, minHeight: 200 }}\n      >\n        <Typography.Paragraph>\n          这是页面的主要内容区域。ButtonFooter 会自动计算高度并设置 CSS 变量，\n          方便页面布局调整。\n        </Typography.Paragraph>\n        <Typography.Paragraph>\n          在移动端，按钮会自动固定在屏幕底部，确保操作按钮始终可见。\n        </Typography.Paragraph>\n      </Card>\n      <ButtonFooter>\n        <Flex justify=\"flex-end\" gap={8} style={{ padding: '16px 24px', background: '#fff', borderTop: '1px solid #f0f0f0' }}>\n          <Button>取消</Button>\n          <Button type=\"primary\">保存</Button>\n        </Flex>\n      </ButtonFooter>\n    </Space>\n  );\n};\n\n// 表单提交场景\nconst FormExample = () => {\n  const [form] = Form.useForm();\n  const [loading, setLoading] = useState(false);\n\n  const handleSave = () => {\n    setLoading(true);\n    setTimeout(() => {\n      setLoading(false);\n      message.success('保存成功');\n    }, 1000);\n  };\n\n  const handleSubmit = () => {\n    setLoading(true);\n    setTimeout(() => {\n      setLoading(false);\n      message.success('提交成功');\n    }, 1000);\n  };\n\n  return (\n    <Card title=\"表单底部操作\" style={{ width: 500 }}>\n      <Space direction=\"vertical\" style={{ width: '100%' }}>\n        <Typography.Text type=\"secondary\">\n          适用于表单页面的底部操作按钮\n        </Typography.Text>\n        <Form form={form} layout=\"vertical\">\n          <Form.Item name=\"name\" label=\"名称\">\n            <Input placeholder=\"请输入名称\" />\n          </Form.Item>\n          <Form.Item name=\"desc\" label=\"描述\">\n            <Input.TextArea placeholder=\"请输入描述\" rows={4} />\n          </Form.Item>\n        </Form>\n        <ButtonFooter>\n          <Flex justify=\"flex-end\" gap={8} style={{ padding: '16px 0', borderTop: '1px solid #f0f0f0' }}>\n            <Button onClick={() => form.resetFields()}>重置</Button>\n            <Button onClick={handleSave}>保存草稿</Button>\n            <Button type=\"primary\" loading={loading} onClick={handleSubmit}>\n              提交\n            </Button>\n          </Flex>\n        </ButtonFooter>\n      </Space>\n    </Card>\n  );\n};\n\n// 居中对齐\nconst CenterExample = () => {\n  return (\n    <Space direction=\"vertical\" style={{ width: '100%' }}>\n      <Typography.Text type=\"secondary\">按钮居中对齐</Typography.Text>\n      <Card title=\"对话框\" style={{ width: 400 }}>\n        <Typography.Paragraph>\n          这是对话框的内容区域，底部按钮居中对齐。\n        </Typography.Paragraph>\n      </Card>\n      <ButtonFooter>\n        <Flex justify=\"center\" gap={8} style={{ padding: '16px 24px', background: '#fff', borderTop: '1px solid #f0f0f0' }}>\n          <Button>关闭</Button>\n          <Button type=\"primary\">确认</Button>\n        </Flex>\n      </ButtonFooter>\n    </Space>\n  );\n};\n\n// 多按钮布局\nconst MultipleButtonsExample = () => {\n  return (\n    <Space direction=\"vertical\" style={{ width: '100%' }}>\n      <Typography.Text type=\"secondary\">多个操作按钮</Typography.Text>\n      <Card title=\"详情页面\" style={{ width: 450 }}>\n        <Typography.Paragraph>\n          页面详情内容区域...\n        </Typography.Paragraph>\n        <Typography.Paragraph>\n          支持多个按钮布局，包括主要操作、次要操作等。\n        </Typography.Paragraph>\n      </Card>\n      <ButtonFooter>\n        <Flex justify=\"space-between\" align=\"middle\" style={{ padding: '12px 24px', background: '#fff', borderTop: '1px solid #f0f0f0' }}>\n          <Space>\n            <Button type=\"text\" danger>删除</Button>\n            <Button type=\"text\">导出</Button>\n          </Space>\n          <Space>\n            <Button>编辑</Button>\n            <Button type=\"primary\">提交审核</Button>\n          </Space>\n        </Flex>\n      </ButtonFooter>\n    </Space>\n  );\n};\n\n// 紧凑样式\nconst CompactExample = () => {\n  return (\n    <Space direction=\"vertical\" style={{ width: '100%' }}>\n      <Typography.Text type=\"secondary\">紧凑样式</Typography.Text>\n      <Card title=\"设置页面\" style={{ width: 400 }}>\n        <Typography.Paragraph>\n          系统设置内容区域...\n        </Typography.Paragraph>\n      </Card>\n      <ButtonFooter>\n        <Flex justify=\"flex-end\" gap={8} style={{ padding: '8px 0', borderTop: '1px solid #f0f0f0' }}>\n          <Button size=\"small\">取消</Button>\n          <Button size=\"small\" type=\"primary\">保存设置</Button>\n        </Flex>\n      </ButtonFooter>\n    </Space>\n  );\n};\n\n// 禁用状态\nconst DisabledExample = () => {\n  const [disabled, setDisabled] = useState(true);\n\n  return (\n    <Space direction=\"vertical\" style={{ width: '100%' }}>\n      <Typography.Text type=\"secondary\">按钮禁用状态</Typography.Text>\n      <Space>\n        <Button onClick={() => setDisabled(!disabled)} size=\"small\">\n          {disabled ? '启用按钮' : '禁用按钮'}\n        </Button>\n      </Space>\n      <Card title=\"详情页\" style={{ width: 400 }}>\n        <Typography.Paragraph>\n          内容区域...\n        </Typography.Paragraph>\n      </Card>\n      <ButtonFooter>\n        <Flex justify=\"flex-end\" gap={8} style={{ padding: '16px 0', borderTop: '1px solid #f0f0f0' }}>\n          <Button disabled={disabled}>编辑</Button>\n          <Button type=\"primary\" disabled={disabled}>\n            提交\n          </Button>\n        </Flex>\n      </ButtonFooter>\n    </Space>\n  );\n};\n\n// 步骤条场景\nconst StepsExample = () => {\n  const [currentStep, setCurrentStep] = useState(0);\n  const totalSteps = 3;\n\n  const nextStep = () => {\n    if (currentStep < totalSteps - 1) {\n      setCurrentStep(currentStep + 1);\n    }\n  };\n\n  const prevStep = () => {\n    if (currentStep > 0) {\n      setCurrentStep(currentStep - 1);\n    }\n  };\n\n  const stepContent = [\n    '第一步：填写基本信息',\n    '第二步：上传相关文件',\n    '第三步：确认提交信息'\n  ];\n\n  return (\n    <Card title=\"步骤操作\" style={{ width: 450 }}>\n      <Space direction=\"vertical\" style={{ width: '100%' }}>\n        <Typography.Text type=\"secondary\">\n          当前步骤：{currentStep + 1} / {totalSteps}\n        </Typography.Text>\n        <div style={{ padding: '24px', background: '#f5f5f5', borderRadius: '8px', minHeight: '100px' }}>\n          <Typography.Text>{stepContent[currentStep]}</Typography.Text>\n        </div>\n        <ButtonFooter>\n          <Flex justify=\"space-between\" style={{ padding: '16px 0', borderTop: '1px solid #f0f0f0' }}>\n            <Button disabled={currentStep === 0} onClick={prevStep}>\n              上一步\n            </Button>\n            <Button\n              type=\"primary\"\n              onClick={currentStep === totalSteps - 1 ? () => message.success('提交成功') : nextStep}\n            >\n              {currentStep === totalSteps - 1 ? '提交' : '下一步'}\n            </Button>\n          </Flex>\n        </ButtonFooter>\n      </Space>\n    </Card>\n  );\n};\n\n// 实际应用场景 - 完整页面\nconst FullPageExample = () => {\n  const [form] = Form.useForm();\n\n  const handleSubmit = () => {\n    message.success('提交成功');\n  };\n\n  const handleSave = () => {\n    message.success('已保存草稿');\n  };\n\n  return (\n    <Card title=\"完整页面示例\" style={{ width: 500 }}>\n      <Space direction=\"vertical\" style={{ width: '100%' }}>\n        <Typography.Text type=\"secondary\">\n          模拟一个完整的表单页面，包含标题、内容区和底部操作按钮\n        </Typography.Text>\n        <div style={{ minHeight: '200px', padding: '20px', background: '#fafafa', borderRadius: '8px' }}>\n          <Typography.Title level={5}>用户信息编辑</Typography.Title>\n          <Form form={form} layout=\"vertical\">\n            <Form.Item name=\"username\" label=\"用户名\">\n              <Input placeholder=\"请输入用户名\" />\n            </Form.Item>\n            <Form.Item name=\"email\" label=\"邮箱\">\n              <Input placeholder=\"请输入邮箱\" />\n            </Form.Item>\n          </Form>\n        </div>\n        <ButtonFooter>\n          <Flex justify=\"flex-end\" gap={12} style={{ padding: '16px 24px', background: '#fff', borderTop: '1px solid #f0f0f0' }}>\n            <Button onClick={() => form.resetFields()}>重置</Button>\n            <Button onClick={handleSave}>保存草稿</Button>\n            <Button type=\"primary\" onClick={handleSubmit}>提交</Button>\n          </Flex>\n        </ButtonFooter>\n      </Space>\n    </Card>\n  );\n};\n\nconst BaseExample = () => {\n  return (\n    <Space direction=\"vertical\" size=\"large\">\n      <Typography.Title level={3}>ButtonFooter 底部按钮区</Typography.Title>\n      <Typography.Paragraph>\n        ButtonFooter 是页面底部按钮区域组件，可以自动计算高度并设置 CSS 变量。\n        在小屏幕（≤768px）下，会将内容渲染到 body，确保按钮始终可见。\n        适用于表单页面、详情页面、对话框等场景。\n      </Typography.Paragraph>\n\n      <Flex vertical gap={32}>\n        <div>\n          <Typography.Title level={4}>基础用法</Typography.Title>\n          <BasicExample />\n        </div>\n\n        <div>\n          <Typography.Title level={4}>表单提交场景</Typography.Title>\n          <FormExample />\n        </div>\n\n        <div>\n          <Typography.Title level={4}>居中对齐</Typography.Title>\n          <CenterExample />\n        </div>\n\n        <div>\n          <Typography.Title level={4}>多按钮布局</Typography.Title>\n          <MultipleButtonsExample />\n        </div>\n\n        <div>\n          <Typography.Title level={4}>紧凑样式</Typography.Title>\n          <CompactExample />\n        </div>\n\n        <div>\n          <Typography.Title level={4}>禁用状态</Typography.Title>\n          <DisabledExample />\n        </div>\n\n        <div>\n          <Typography.Title level={4}>步骤操作</Typography.Title>\n          <StepsExample />\n        </div>\n\n        <div>\n          <Typography.Title level={4}>完整页面示例</Typography.Title>\n          <FullPageExample />\n        </div>\n      </Flex>\n    </Space>\n  );\n};\n\nrender(<BaseExample />);\n\n`,\n    scope: [{\n    name: \"_ButtonGroup\",\n    packageName: \"@kne/current-lib_button-group\",\n    importStatement: \"import * as _ButtonGroup from \\\"@kne/button-group\\\"\",\n    component: component_1\n},{\n    name: \"antd\",\n    packageName: \"antd\",\n    component: component_2\n}]\n}]\n    }\n};\nexport default readmeConfig;\n"],"names":["name","summary","description","packageName","api","example","isFull","className","style","list","title","code","scope","importStatement","component"],"sourceRoot":""}